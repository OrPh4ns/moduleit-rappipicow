/*
@author Abdulrahman Othman
@email  abdulrahman.othman@web.de
@date   1.10.2023
@brief  Blind UHF Project
*/

// 0. Hardware version
const byte HardwareVersion[] = {0xBB, 0x00, 0x03, 0x00, 0x01, 0x00, 0x04, 0x7E};

// 1. Software version
const byte SoftwareVersion[] = {0xBB, 0x00, 0x03, 0x00, 0x01, 0x01, 0x05, 0x7E};

// 2. Manufacturers
const byte Manufacturers[] = {0xBB, 0x00, 0x03, 0x00, 0x01, 0x02, 0x06, 0x7E};

// 3. Single polling instruction
const byte SinglePollingInstruction[] = {0xBB, 0x00, 0x22, 0x00, 0x00, 0x22, 0x7E};

// 4. Multiple polling instructions
const byte MultiplePollingInstructions[] = {0xBB, 0x00, 0x27, 0x00, 0x03, 0x22, 0x27, 0x10, 0x83, 0x7E};

// 5. Stop multiple polling instructions
const byte StopMultiplePollingInstructions[] = {0xBB, 0x00, 0x28, 0x00, 0x00, 0x28, 0x7E};

// 6. Set the SELECT parameter instruction
const byte SetSelectParameterInstruction[] = {0xBB, 0x00, 0x0C, 0x00, 0x13, 0x01, 0x00, 0x00, 0x00, 0x20, 0x60, 0x00, 0x30, 0x75, 0x1F, 0xEB, 0x70, 0x5C, 0x59, 0x04, 0xE3, 0xD5, 0x0D, 0x70, 0xAD, 0x7E};

// 7. Get the SELECT parameter
const byte GetSelectParameter[] = {0xBB, 0x00, 0x0B, 0x00, 0x00, 0x0B, 0x7E};

// 8. Set the SELECT mode
const byte SetSelectMode[] = {0xBB, 0x00, 0x12, 0x00, 0x01, 0x01, 0x14, 0x7E};

// 9. Read label data storage area
const byte ReadLabelDataStorageArea[] = {0xBB, 0x00, 0x39, 0x00, 0x09, 0x00, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x02, 0x45, 0x7E};

// 10. Write the label data store
const byte WriteLabelDataStore[] = {0xBB, 0x00, 0x49, 0x00, 0x0D, 0x00, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x02, 0x12, 0x34, 0x56, 0x78, 0x6D, 0x7E};

// 11. Lock the LOCK label data store
const byte LockLabelDataStore[] = {0xBB, 0x00, 0x82, 0x00, 0x07, 0x00, 0x00, 0xFF, 0xFF, 0x02, 0x00, 0x80, 0x09, 0x7E};

// 12. Inactivate the kill tag
const byte InactivateKillTag[] = {0xBB, 0x00, 0x65, 0x00, 0x04, 0x00, 0x00, 0xFF, 0xFF, 0x67, 0x7E};

// 13. Set communication baud rate
const byte SetBaudRate[] = {0xBB, 0x00, 0x11, 0x00, 0x02, 0x00, 0xC0, 0xD3, 0x7E};

// 14. Get parameters related to the Query command
const byte GetQueryParameters[] = {0xBB, 0x00, 0x0D, 0x00, 0x00, 0x0D, 0x7E};

// 15. Set the Query parameter
const byte SetQueryParameter[] = {0xBB, 0x00, 0x0E, 0x00, 0x02, 0x10, 0x20, 0x40, 0x7E};

// 16. Set up work area
const byte SetUpWorkArea[] = {0xBB, 0x00, 0x07, 0x00, 0x01, 0x01, 0x09, 0x7E};

// 17. Acquire work locations
const byte AcquireWorkLocations[] = {0xBB, 0x00, 0x08, 0x00, 0x00, 0x08, 0x7E};

// 18. Set up working channel
const byte SetUpWorkingChannel[] = {0xBB, 0x00, 0xAB, 0x00, 0x01, 0x01, 0xAC, 0x7E};

// 19. Get the working channel
const byte GetWorkingChannel[] = {0xBB, 0x00, 0xAA, 0x00, 0x00, 0xAA, 0x7E};

// 20. Set to automatic frequency hopping mode
const byte SetAutomaticFrequencyHopping[] = {0xBB, 0x00, 0xAD, 0x00, 0x01, 0xFF, 0xAD, 0x7E};

// 21. Insert the working channel
const byte InsertWorkingChannel[] = {0xBB, 0x00, 0xA9, 0x00, 0x06, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05, 0xC3, 0x7E};

// 22. Acquire transmitting power
const byte AcquireTransmittingPower[] = {0xBB, 0x00, 0xB7, 0x00, 0x00, 0xB7, 0x7E};

// 23. Set the transmitting power
const byte SetTransmittingPower[] = {0xBB, 0x00, 0xB6, 0x00, 0x02, 0x07, 0xD0, 0x8F, 0x7E};

// 24. Set up transmitting continuous carrier
const byte SetTransmittingContinuousCarrier[] = {0xBB, 0x00, 0xB0, 0x00, 0x01, 0xFF, 0xB0, 0x7E};

// 25. Gets the receiving demodulator parameters
const byte GetReceivingDemodulatorParameters[] = {0xBB, 0x00, 0xF1, 0x00, 0x00, 0xF1, 0x7E};

// 26. Set the receiving demodulator parameters
const byte SetReceivingDemodulatorParameters[] = {0xBB, 0x00, 0xF0, 0x00, 0x04, 0x03, 0x06, 0x01, 0xB0, 0xAE, 0x7E};

// 27. Test the RF input block signal
const byte TestRFInputBlockSignal[] = {0xBB, 0x00, 0xF2, 0x00, 0x00, 0xF2, 0x7E};

// 28. Test the RSSI signal at the RF input
const byte TestRSSISignalAtRFInput[] = {0xBB, 0x00, 0xF3, 0x00, 0x00, 0xF3, 0x7E};

// 30. Module hibernation
const byte ModuleHibernation[] = {0x00, 0xBB, 0x00, 0x17, 0x00, 0x00, 0x17, 0x7E};

// 31. Idle hibernation time of module
const byte IdleHibernationTimeOfModule[] = {0xBB, 0x00, 0x1D, 0x00, 0x01, 0x02, 0x20, 0x7E};

// 32. The IDLE mode
const byte IdleMode[] = {0xBB, 0x00, 0x04, 0x00, 0x03, 0x01, 0x01, 0x03, 0x0C, 0x7E};

// 33. NXP G2X label supports ReadProtect/Reset ReadProtect command
const byte NXPG2XLabelSupportsReadProtect[] = {0xBB, 0x00, 0xE1, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xE4, 0x7E};

// 34. The NXP G2X label supports the CHANGE EAS directive
const byte NXPG2XLabelSupportsChangeEAS[] = {0xBB, 0x00, 0xE3, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0xE7, 0x7E};

// 35. The NXP G2X tag supports the EAS_ALARM directive
const byte NXPG2XTagSupportsEASAlarm[] = {0xBB, 0x00, 0xE4, 0x00, 0x00, 0xE4, 0x7E};

// 36. NXP G2X label 16bits config-word
const byte NXPG2XLabel16BitsConfigWord[] = {0xBB, 0x00, 0xE0, 0x00, 0x06, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xE4, 0x7E};

// 37. Impinj Monza 4 Qt tags support Qt instructions
const byte ImpinjMonza4QtSupportsQtInstructions[] = {0xBB, 0x00, 0xE5, 0x00, 0x08, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x01, 0x40, 0x00, 0x2D, 0x7E};

// 38. The BlockPermalock directive permanently locks blocks of a user's Block
const byte BlockPermalockDirective[] = {0xBB, 0x00, 0xD3, 0x00, 0x0B, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x03, 0x00, 0x00, 0x01, 0x07, 0x00, 0xE8, 0x7E};

char a[] = {};
void setup()
{
  Serial1.setTimeout(10);
  // Start serial communication on Serial1 (TX1, RX0) at the desired baud rate
  Serial1.begin(115200); // Change the baud rate to match your sensor's specification
  Serial.begin(115200);
}

void loop()
{
  Serial1.write(GetWorkingChannel, sizeof(GetWorkingChannel));
  Serial.println("GetWorkingChannel ][ "+Serial1.readString());
  //Serial.println(Serial1.readBytes(a, sizeof(a)));
  // delay(1000);
  //Serial1.write(GetQueryParameters, sizeof(GetQueryParameters));
  //Serial.println("GetQueryParameters ][ "+Serial1.readString());

  //Serial.println(" ");
}